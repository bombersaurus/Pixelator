<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Poly Pixelator — Sora's Pixel Converter</title>
<style>
  :root {
    --win-bg: #C0C0C0;
    --win-highlight: #ffffff;
    --win-shadow: #808080;
    --win-shadow-dark: #404040;
    --win-title: #000080;
    --check-light: #606060;
    --check-dark: #404040;
    --bg-green: #006044;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'MS Sans Serif', 'Microsoft Sans Serif', 'Segoe UI', Tahoma, sans-serif;
    font-size: 11px;
    color: #000;
    height: 100vh;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    overflow-x: hidden;
    background: var(--bg-green);
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: unset;
  }

  body.bg-checkered {
    background-color: var(--check-light);
    background-image:
      linear-gradient(45deg, var(--check-dark) 25%, transparent 25%),
      linear-gradient(-45deg, var(--check-dark) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--check-dark) 75%),
      linear-gradient(-45deg, transparent 75%, var(--check-dark) 75%);
    background-size: 16px 16px;
    background-position: 0 0, 0 8px, 8px -8px, -8px 0;
  }

  .main-row {
    flex: 1;
    display: flex;
    min-height: 0;
  }

  /* ── Canvas area ─────────────────────────────────────────────────────────── */
  .canvas-area {
    flex: 1;
    padding: 8px;
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 0;
    cursor: default;
  }

  /* ── Right sidebar: Background toggle ─────────────────────────────────────── */
  .right-sidebar {
    width: 140px;
    min-width: 140px;
    flex-shrink: 0;
    padding: 8px;
    border-left: 1px solid var(--win-shadow);
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: var(--win-bg);
  }

  .bg-section .title-bar {
    margin-bottom: 0;
  }

  .bg-section .section-content {
    flex-direction: column;
    padding: 8px;
    gap: 8px;
  }

  .bg-option {
    width: 100%;
    padding: 16px 12px;
    font-family: inherit;
    font-size: 12px;
    font-weight: bold;
    min-height: 48px;
  }

  /* Fixed window — Win95 style, sharp corners, 3D bevel */
  .preview-window {
    display: flex;
    flex-direction: column;
    width: 84%;
    height: 84%;
    max-width: 84%;
    max-height: 84%;
    min-width: 200px;
    min-height: 150px;
    border: 2px solid;
    border-color: var(--win-highlight) var(--win-shadow-dark) var(--win-shadow-dark) var(--win-highlight);
    background: var(--win-bg);
  }

  .preview-window .window-title-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--win-title);
    color: #fff;
    font-weight: bold;
    font-size: 11px;
    padding: 2px 4px 2px 6px;
    height: 18px;
    min-height: 18px;
  }

  /* Canvas frame — sunken/inset 3D */
  .canvas-frame {
    flex: 1;
    padding: 4px;
    margin: 2px;
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-shadow-dark) var(--win-highlight) var(--win-highlight) var(--win-shadow-dark);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
    cursor: pointer;
    min-height: 0;
  }

  .canvas-frame.border-blackwhite {
    border: 8px solid #000 !important;
    box-shadow: inset 0 0 0 2px #fff !important;
  }
  .canvas-frame.border-navy {
    border: 8px solid #000080 !important;
    box-shadow: inset 0 0 0 2px #4169e1 !important;
  }

  .canvas-frame:hover {
    background: #c8c8c8;
  }

  .canvas-frame canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    display: block;
    background: #808080;
  }

  .placeholder {
    color: #808080;
    font-style: italic;
    font-size: 11px;
    text-align: center;
    padding: 16px;
  }

  .placeholder strong {
    display: block;
    margin-bottom: 4px;
    color: #404040;
  }

  /* ── Bottom dock — Win95 grey panels ─────────────────────────────────────── */
  .bottom-dock {
    display: flex;
    align-items: stretch;
    gap: 8px;
    padding: 10px 10px 10px 10px;
    margin-bottom: 8px;
    background: var(--win-bg);
    border-top: 1px solid var(--win-shadow);
    flex-wrap: wrap;
  }

  .dock-section {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .dock-section:not(:last-child) {
    padding-right: 8px;
    margin-right: 0;
    border-right: 1px solid var(--win-shadow);
  }

  .titled-section {
    flex-direction: column;
    align-items: stretch;
    gap: 0;
    border: 2px solid;
    border-color: var(--win-highlight) var(--win-shadow) var(--win-shadow) var(--win-highlight);
  }
  .titled-section .section-content {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 2px 4px;
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-shadow-dark) var(--win-highlight) var(--win-highlight) var(--win-shadow-dark);
    margin: 2px;
  }

  .title-bar {
    background: var(--win-title);
    color: #fff;
    font-weight: bold;
    font-size: 11px;
    padding: 2px 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .win-btn {
    padding: 4px 12px;
    font-family: inherit;
    font-size: 11px;
    color: #000;
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-highlight) var(--win-shadow) var(--win-shadow) var(--win-highlight);
    cursor: pointer;
    touch-action: manipulation;
  }
  .win-btn:hover {
    background: #d4d0c8;
  }
  .win-btn:active {
    border-color: var(--win-shadow) var(--win-highlight) var(--win-highlight) var(--win-shadow);
  }

  .toggle-btn {
    padding: 4px 10px;
    font-family: inherit;
    font-size: 11px;
    color: #000;
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-highlight) var(--win-shadow) var(--win-shadow) var(--win-highlight);
    cursor: pointer;
    touch-action: manipulation;
  }
  .toggle-btn:hover {
    background: #d4d0c8;
  }
  .toggle-btn.pressed {
    border-color: var(--win-shadow) var(--win-highlight) var(--win-highlight) var(--win-shadow);
    background: #a0a0a0;
  }

  /* DIALOG panel */
  .dialog-panel {
    flex-wrap: wrap !important;
    gap: 6px !important;
  }
  .dialog-styles {
    display: flex;
    gap: 2px;
  }
  .dialog-style-btn { padding: 2px 6px; font-size: 10px; }
  .dialog-input-row {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .dialog-input-row label { font-size: 10px; width: 28px; }
  .dialog-input {
    font-family: 'MS Sans Serif', 'Microsoft Sans Serif', 'Segoe UI', Tahoma, sans-serif;
    font-size: 11px;
    padding: 2px 6px;
    width: 70px;
    border: 2px solid;
    border-color: var(--win-shadow-dark) var(--win-highlight) var(--win-highlight) var(--win-shadow-dark);
    background: #fff;
  }
  .dialog-slider-row {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .dialog-slider-row label { font-size: 10px; white-space: nowrap; }
  .dialog-slider {
    width: 60px;
    height: 14px;
    cursor: pointer;
  }

  /* Palette buttons */
  .palette-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    padding: 2px 6px;
    min-width: 56px;
  }
  .palette-btn .swatch {
    display: grid;
    grid-template-columns: repeat(4, 6px);
    gap: 1px;
  }
  .palette-btn .swatch span {
    width: 6px;
    height: 6px;
    display: block;
  }
  .palette-btn span.name { font-size: 10px; }

  .palette-scroll {
    max-width: 400px;
    max-height: 64px;
    overflow-x: auto;
    overflow-y: hidden;
    display: flex;
    gap: 4px;
    padding: 2px;
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-shadow-dark) var(--win-highlight) var(--win-highlight) var(--win-shadow-dark);
  }
  .palette-scroll::-webkit-scrollbar { height: 16px; }
  .palette-scroll::-webkit-scrollbar-track {
    background: var(--win-bg);
    border: 1px solid var(--win-shadow);
  }
  .palette-scroll::-webkit-scrollbar-thumb {
    background: var(--win-bg);
    border: 2px solid;
    border-color: var(--win-highlight) var(--win-shadow) var(--win-shadow) var(--win-highlight);
  }

  .status-bar {
    padding: 8px 10px;
    margin-top: 0;
    font-size: 11px;
    color: #000;
    background: var(--win-bg);
    border-top: 1px solid var(--win-shadow);
  }

  .drop-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 128, 128, 0.25);
    border: 3px dashed var(--win-title);
    z-index: 100;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-family: inherit;
    color: #000;
    pointer-events: none;
  }
  .drop-overlay.visible { display: flex; }

  /* ── Mobile responsive ───────────────────────────────────────────────────── */
  @media (max-width: 768px) {
    body { overflow-y: auto; }
    .main-row { flex-direction: column; flex: none; }
    .right-sidebar { display: none; }
    .canvas-area {
      flex: none;
      height: 44vh;
      height: 44dvh;
      min-height: 200px;
      padding: 4px;
    }
    .preview-window {
      width: 100%; height: 100%;
      max-width: 100%; max-height: 100%;
      min-width: 0; min-height: 0;
    }
    .bottom-dock {
      flex: none;
      flex-direction: column;
      gap: 2px;
      padding: 6px;
      margin-bottom: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .dock-section {
      flex-wrap: wrap;
      border-right: none !important;
      padding-right: 0 !important;
    }
    .titled-section { width: 100%; }
    .titled-section .section-content { flex-wrap: wrap; gap: 6px; padding: 6px; }
    .win-btn, .toggle-btn {
      min-height: 40px;
      min-width: 40px;
      padding: 10px 14px;
      font-size: 13px;
    }
    .dialog-styles { flex-wrap: wrap; gap: 4px; }
    .dialog-style-btn { min-height: 36px; padding: 8px 10px; font-size: 12px; }
    .dialog-input-row, .dialog-slider-row { width: 100%; }
    .dialog-input-row label, .dialog-slider-row label { font-size: 12px; width: 50px; }
    .dialog-input { flex: 1; font-size: 16px; padding: 8px; width: auto; min-width: 0; }
    .dialog-slider { flex: 1; height: 32px; width: auto; min-width: 0; }
    .palette-scroll { max-width: 100%; overflow-x: auto; }
    .palette-btn { min-width: 60px; padding: 4px 8px; }
    .palette-btn .swatch { grid-template-columns: repeat(4, 8px); }
    .palette-btn .swatch span { width: 8px; height: 8px; }
    .palette-btn span.name { font-size: 11px; }
    .status-bar { font-size: 10px; padding: 4px 8px; }
  }
</style>
</head>
<body id="body">

<div class="main-row">
<div class="canvas-area" id="canvasArea">
  <div class="preview-window" id="previewWindow">
    <div class="window-title-bar" id="windowTitleBar">
      <span>pixalator</span>
    </div>
    <div class="canvas-frame" id="canvasFrame">
      <canvas id="canvas" width="0" height="0"></canvas>
      <div class="placeholder" id="placeholder">
        <strong>Click or drop image here</strong>
        Load an image to pixelate
      </div>
    </div>
  </div>
</div>

<div class="right-sidebar">
  <div class="dock-section titled-section bg-section">
    <div class="title-bar">Background colours</div>
    <div class="section-content">
      <button class="toggle-btn bg-option pressed" data-bg="greenish">piss 1</button>
      <button class="toggle-btn bg-option" data-bg="checkered">piss 2</button>
    </div>
  </div>
</div>
</div>

<div class="bottom-dock">
  <div class="dock-section">
    <button class="win-btn" id="loadBtn">Load</button>
    <button class="win-btn" id="saveBtn">Save PNG</button>
  </div>

  <div class="dock-section titled-section">
    <div class="title-bar">Size</div>
    <div class="section-content">
      <button class="toggle-btn" data-size="1">1px</button>
      <button class="toggle-btn" data-size="2">2px</button>
      <button class="toggle-btn" data-size="4">4px</button>
      <button class="toggle-btn pressed" data-size="6">6px</button>
    </div>
  </div>

  <div class="dock-section titled-section">
    <div class="title-bar">FX</div>
    <div class="section-content">
      <button class="toggle-btn" data-fx="dither">Dither</button>
      <button class="toggle-btn" data-fx="ghost">Ghost</button>
      <button class="toggle-btn" data-fx="outline">Outline</button>
    </div>
  </div>

  <div class="dock-section titled-section">
    <div class="title-bar">Palette</div>
    <div class="section-content">
      <div class="palette-scroll" id="paletteScroll"></div>
    </div>
  </div>

  <div class="dock-section titled-section">
    <div class="title-bar">Border</div>
    <div class="section-content">
      <button class="toggle-btn" id="borderToggle">OFF</button>
      <button class="toggle-btn border-btn pressed" data-border="blackwhite">Black/White</button>
      <button class="toggle-btn border-btn" data-border="navy">Navy</button>
    </div>
  </div>

  <div class="dock-section titled-section">
    <div class="title-bar">DIALOG</div>
    <div class="section-content dialog-panel">
      <button class="toggle-btn" id="dialogToggle" data-on="OFF">OFF</button>
      <div class="dialog-styles">
        <button class="toggle-btn dialog-style-btn pressed" data-style="jrpg">JRPG</button>
        <button class="toggle-btn dialog-style-btn" data-style="classic">Classic</button>
        <button class="toggle-btn dialog-style-btn" data-style="modern">Modern</button>
        <button class="toggle-btn dialog-style-btn" data-style="ghost">Ghost</button>
      </div>
      <div class="dialog-input-row">
        <label>Name</label>
        <input type="text" class="dialog-input" id="dialogName" placeholder="Fern" maxlength="32">
      </div>
      <div class="dialog-input-row">
        <label>Text</label>
        <input type="text" class="dialog-input" id="dialogText" placeholder=":3" maxlength="128">
      </div>
      <div class="dialog-slider-row">
        <label>Position</label>
        <input type="range" class="dialog-slider" id="dialogPosition" min="0" max="100" value="85">
      </div>
      <div class="dialog-slider-row">
        <label>Box Size</label>
        <input type="range" class="dialog-slider" id="dialogBoxSize" min="10" max="100" value="45" step="1">
      </div>
    </div>
  </div>
</div>

<div class="status-bar" id="status">Ready</div>
<div class="drop-overlay" id="dropOverlay">Drop image here</div>

<input type="file" id="filePicker" accept="image/*" hidden>

<script>
/* ═══════════════════════════════════════════════════════════════════════════
   PALETTES
   ═══════════════════════════════════════════════════════════════════════════ */

const PALETTES = {
  frutigeraero: [
    [0x1a,0x3d,0x5c],[0x2d,0x6b,0x9a],[0x4a,0x9f,0xd4],[0x7e,0xb8,0xda],
    [0xa8,0xcf,0xe8],[0xd0,0xe8,0xf5],[0xec,0xf4,0xfa],[0xff,0xff,0xff],
    [0x2e,0xcc,0x71],[0x34,0x98,0xdb],[0x9b,0x59,0xb6],[0xe7,0x4c,0x3c],
    [0xf3,0x9c,0x12],[0x1a,0xbc,0x9c],[0xfd,0xad,0xb9],[0xb8,0xe0,0xf0],
  ],
  glossyvista: [
    [0x00,0xd4,0xff],[0x33,0xdd,0xff],[0x66,0xe6,0xff],[0x99,0xf0,0xff],
    [0x33,0xff,0x33],[0x66,0xff,0x66],[0x99,0xff,0x99],[0xff,0xff,0xff],
    [0x87,0xce,0xeb],[0x4a,0x90,0xe2],[0x1e,0x3a,0x8a],[0x0a,0x1f,0x5c],
    [0x00,0xbf,0xff],[0x7f,0xff,0x00],[0xff,0xff,0xff],[0x00,0x80,0xff],
  ],
  warmautumn: [
    [0x1a,0x0a,0x00],[0x4a,0x20,0x00],[0x8b,0x45,0x00],[0xc6,0x78,0x00],
    [0xcd,0x85,0x32],[0xe6,0x99,0x33],[0xff,0xb3,0x47],[0xff,0xcc,0x80],
    [0x8b,0x45,0x13],[0xa0,0x52,0x2d],[0xcd,0x5c,0x5c],[0xda,0x70,0x6a],
    [0x4a,0x2c,0x0a],[0x6b,0x3e,0x1a],[0xff,0xd7,0x00],[0xff,0xef,0xd5],
  ],
  universal: [
    [0x14,0x0c,0x1c],[0x44,0x24,0x34],[0x30,0x34,0x6d],[0x4e,0x4a,0x4e],
    [0x85,0x4c,0x30],[0x34,0x65,0x24],[0xd0,0x46,0x48],[0x75,0x71,0x61],
    [0x59,0x7d,0xce],[0xd2,0x7d,0x2c],[0x85,0x95,0xa1],[0x6d,0xaa,0x2c],
    [0xd2,0xaa,0x99],[0x6d,0xc2,0xca],[0xda,0xd4,0x5e],[0xde,0xee,0xd6],
  ],
};

const PALETTE_NAMES = {
  original: 'Original',
  universal: 'Universal',
  frutigeraero: 'Frutiger Aero',
  glossyvista: 'Glossy Vista',
  warmautumn: 'Warm Autumn',
};

const PALETTE_ORDER = ['original', 'universal', 'frutigeraero', 'glossyvista', 'warmautumn'];

function extractOriginalPalette(data, w, h) {
  const colors = [];
  const step = Math.max(1, Math.floor((w * h) / 4096));
  for (let i = 0; i < data.length; i += step * 4) {
    if (data[i + 3] > 128) {
      colors.push([data[i], data[i + 1], data[i + 2]]);
    }
  }
  if (colors.length < 16) {
    const out = [...colors];
    while (out.length < 16) out.push(colors[out.length % colors.length] || [128, 128, 128]);
    return out.slice(0, 16);
  }
  function splitBox(arr) {
    let minR = 255, maxR = 0, minG = 255, maxG = 0, minB = 255, maxB = 0;
    for (const c of arr) {
      minR = Math.min(minR, c[0]); maxR = Math.max(maxR, c[0]);
      minG = Math.min(minG, c[1]); maxG = Math.max(maxG, c[1]);
      minB = Math.min(minB, c[2]); maxB = Math.max(maxB, c[2]);
    }
    const spanR = maxR - minR, spanG = maxG - minG, spanB = maxB - minB;
    const ch = spanR >= spanG && spanR >= spanB ? 0 : spanG >= spanB ? 1 : 2;
    arr.sort((a, b) => a[ch] - b[ch]);
    const mid = Math.floor(arr.length / 2);
    return [arr.slice(0, mid), arr.slice(mid)];
  }
  let boxes = [colors];
  while (boxes.length < 16) {
    let best = -1, bestSize = 0;
    for (let i = 0; i < boxes.length; i++) {
      if (boxes[i].length > bestSize) { bestSize = boxes[i].length; best = i; }
    }
    if (best < 0 || bestSize <= 1) break;
    const [a, b] = splitBox([...boxes[best]]);
    boxes = [...boxes.slice(0, best), ...(a.length ? [a] : []), ...(b.length ? [b] : []), ...boxes.slice(best + 1)];
  }
  while (boxes.length < 16) boxes.push([[128, 128, 128]]);
  return boxes.slice(0, 16).map(box => {
    let r = 0, g = 0, b = 0;
    for (const c of box) { r += c[0]; g += c[1]; b += c[2]; }
    const n = box.length || 1;
    return [Math.round(r / n), Math.round(g / n), Math.round(b / n)];
  });
}

/* 8×8 Bayer matrix (0–63) */
const BAYER_8X8 = [
  [ 0,32, 8,40, 2,34,10,42],
  [48,16,56,24,50,18,58,26],
  [12,44, 4,36,14,46, 6,38],
  [60,28,52,20,62,30,54,22],
  [ 3,35,11,43, 1,33, 9,41],
  [51,19,59,27,49,17,57,25],
  [15,47, 7,39,13,45, 5,37],
  [63,31,55,23,61,29,53,21],
];

/* ═══════════════════════════════════════════════════════════════════════════
   STATE
   ═══════════════════════════════════════════════════════════════════════════ */

let blockSize = 6;
let ditherEnabled = false;
let ghostEnabled = false;
let outlineEnabled = false;
let currentPalette = 'universal';
let originalImageData = null;
let cachedOriginalPalette = null;

let dialogEnabled = false;
let dialogStyle = 'jrpg';
let dialogName = '';
let dialogText = '';
let dialogPosition = 85;
let dialogBoxSize = 45;
let dialogRepaintTimeout = null;
let borderEnabled = false;
let borderStyle = 'blackwhite';
let srcWidth = 0;
let srcHeight = 0;

let _rafPending = false;
function scheduleProcess() {
  if (_rafPending) return;
  _rafPending = true;
  requestAnimationFrame(() => {
    _rafPending = false;
    processAndPaint();
  });
}

/* ═══════════════════════════════════════════════════════════════════════════
   DOM & PALETTE GRID
   ═══════════════════════════════════════════════════════════════════════════ */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const filePicker = document.getElementById('filePicker');
const status = document.getElementById('status');
const placeholder = document.getElementById('placeholder');
const paletteScroll = document.getElementById('paletteScroll');

function getPaletteForDisplay(key) {
  if (key === 'original') {
    return cachedOriginalPalette || Array.from({ length: 16 }, (_, i) => {
      const v = Math.round((i / 15) * 255);
      return [v, v, v];
    });
  }
  return PALETTES[key];
}

function buildPaletteGrid() {
  paletteScroll.innerHTML = '';
  for (const key of PALETTE_ORDER) {
    const palette = getPaletteForDisplay(key);
    if (!palette) continue;
    const btn = document.createElement('button');
    btn.className = 'toggle-btn palette-btn' + (key === currentPalette ? ' pressed' : '');
    btn.dataset.palette = key;
    const swatch = document.createElement('span');
    swatch.className = 'swatch';
    swatch.innerHTML = palette.slice(0, 16).map(([r,g,b]) =>
      `<span style="background:rgb(${r},${g},${b})"></span>`
    ).join('');
    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = PALETTE_NAMES[key];
    btn.appendChild(swatch);
    btn.appendChild(name);
    btn.addEventListener('click', () => {
      document.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('pressed'));
      btn.classList.add('pressed');
      currentPalette = key;
      scheduleProcess();
    });
    paletteScroll.appendChild(btn);
  }
}
buildPaletteGrid();

/* ═══════════════════════════════════════════════════════════════════════════
   LOAD / SAVE
   ═══════════════════════════════════════════════════════════════════════════ */

document.getElementById('loadBtn').addEventListener('click', () => filePicker.click());

// Click on canvas frame → load image (entire frame is clickable)
document.getElementById('canvasFrame').addEventListener('click', () => filePicker.click());

filePicker.addEventListener('change', () => {
  if (filePicker.files.length) loadFile(filePicker.files[0]);
});

document.getElementById('saveBtn').addEventListener('click', () => {
  if (!originalImageData) return;
  const link = document.createElement('a');
  link.download = 'pixelated.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const img = new Image();
    img.onload = () => {
      srcWidth = img.naturalWidth;
      srcHeight = img.naturalHeight;
      const tmp = document.createElement('canvas');
      tmp.width = srcWidth;
      tmp.height = srcHeight;
      const tCtx = tmp.getContext('2d');
      tCtx.drawImage(img, 0, 0);
      originalImageData = tCtx.getImageData(0, 0, srcWidth, srcHeight);
      cachedOriginalPalette = null;
      placeholder.style.display = 'none';
      status.textContent = `Loaded: ${file.name}  (${srcWidth} × ${srcHeight})`;
      scheduleProcess();
      buildPaletteGrid();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

/* Drag & drop */
let dragCounter = 0;
const dropOverlay = document.getElementById('dropOverlay');
document.addEventListener('dragenter', (e) => { e.preventDefault(); dragCounter++; dropOverlay.classList.add('visible'); });
document.addEventListener('dragleave', (e) => { e.preventDefault(); if (--dragCounter <= 0) { dragCounter = 0; dropOverlay.classList.remove('visible'); } });
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', (e) => {
  e.preventDefault();
  dragCounter = 0;
  dropOverlay.classList.remove('visible');
  const file = e.dataTransfer.files[0];
  if (file && file.type.startsWith('image/')) loadFile(file);
});

/* ═══════════════════════════════════════════════════════════════════════════
   TOGGLES (Size, FX)
   ═══════════════════════════════════════════════════════════════════════════ */

document.querySelectorAll('[data-size]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-size]').forEach(b => b.classList.remove('pressed'));
    btn.classList.add('pressed');
    blockSize = parseInt(btn.dataset.size, 10);
    scheduleProcess();
  });
});

document.querySelectorAll('[data-bg]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-bg]').forEach(b => b.classList.remove('pressed'));
    btn.classList.add('pressed');
    const body = document.getElementById('body');
    if (btn.dataset.bg === 'checkered') {
      body.classList.add('bg-checkered');
    } else {
      body.classList.remove('bg-checkered');
    }
  });
});

document.querySelectorAll('[data-fx]').forEach(btn => {
  btn.addEventListener('click', () => {
    btn.classList.toggle('pressed');
    const fx = btn.dataset.fx;
    if (fx === 'dither') ditherEnabled = btn.classList.contains('pressed');
    if (fx === 'ghost') ghostEnabled = btn.classList.contains('pressed');
    if (fx === 'outline') outlineEnabled = btn.classList.contains('pressed');
    scheduleProcess();
  });
});

/* ═══════════════════════════════════════════════════════════════════════════
   BORDER
   ═══════════════════════════════════════════════════════════════════════════ */

const canvasFrame = document.getElementById('canvasFrame');

function applyBorderStyles() {
  canvasFrame.classList.remove('border-blackwhite', 'border-navy');
  if (borderEnabled) canvasFrame.classList.add('border-' + borderStyle);
}

document.getElementById('borderToggle').addEventListener('click', function() {
  borderEnabled = !borderEnabled;
  this.textContent = borderEnabled ? 'ON' : 'OFF';
  this.classList.toggle('pressed', borderEnabled);
  applyBorderStyles();
});

document.querySelectorAll('.border-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.border-btn').forEach(b => b.classList.remove('pressed'));
    btn.classList.add('pressed');
    borderStyle = btn.dataset.border;
    applyBorderStyles();
  });
});

/* ═══════════════════════════════════════════════════════════════════════════
   DIALOG PANEL
   ═══════════════════════════════════════════════════════════════════════════ */

function scheduleDialogRepaint() {
  if (dialogRepaintTimeout) clearTimeout(dialogRepaintTimeout);
  dialogRepaintTimeout = setTimeout(scheduleProcess, 80);
}

document.getElementById('dialogToggle').addEventListener('click', function() {
  dialogEnabled = !dialogEnabled;
  this.textContent = dialogEnabled ? 'ON' : 'OFF';
  this.dataset.on = dialogEnabled ? 'ON' : 'OFF';
  this.classList.toggle('pressed', dialogEnabled);
  scheduleProcess();
});

document.querySelectorAll('.dialog-style-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.dialog-style-btn').forEach(b => b.classList.remove('pressed'));
    btn.classList.add('pressed');
    dialogStyle = btn.dataset.style;
    scheduleProcess();
  });
});

document.getElementById('dialogName').addEventListener('input', function() {
  dialogName = this.value.trim();
  scheduleDialogRepaint();
});
document.getElementById('dialogText').addEventListener('input', function() {
  dialogText = this.value.trim();
  scheduleDialogRepaint();
});

document.getElementById('dialogPosition').addEventListener('input', function() {
  dialogPosition = parseInt(this.value, 10);
  scheduleProcess();
});
document.getElementById('dialogBoxSize').addEventListener('input', function() {
  dialogBoxSize = parseInt(this.value, 10);
  scheduleProcess();
});

/* ═══════════════════════════════════════════════════════════════════════════
   PROCESSING PIPELINE (unchanged — Redmean, block downsampling, Bayer dither)
   ═══════════════════════════════════════════════════════════════════════════ */

function processAndPaint() {
  if (!originalImageData) return;
  const t0 = performance.now();

  const w = srcWidth;
  const h = srcHeight;
  const palette = currentPalette === 'original'
    ? (cachedOriginalPalette = extractOriginalPalette(originalImageData.data, w, h))
    : PALETTES[currentPalette];

  let result = applyPaletteBayer(
    downsampleBlocks(originalImageData.data, w, h, blockSize),
    w, h, blockSize, palette, ditherEnabled
  );
  if (outlineEnabled) result = applyOutline(result, w, h, blockSize, palette);
  if (ghostEnabled) result = applyGhost(result, w, h, 10, 10, 0.3);

  canvas.width = w;
  canvas.height = h;
  const outData = ctx.createImageData(w, h);
  outData.data.set(result);
  ctx.putImageData(outData, 0, 0);

  if (dialogEnabled) {
    drawDialogOverlay(ctx, w, h);
  }

  if (borderEnabled) {
    drawCanvasBorder(ctx, w, h);
  }

  const ms = (performance.now() - t0).toFixed(1);
  status.textContent = `Processed in ${ms} ms  |  Block: ${blockSize}px  |  Dither: ${ditherEnabled ? 'ON' : 'OFF'}  |  Ghost: ${ghostEnabled ? 'ON' : 'OFF'}  |  Outline: ${outlineEnabled ? 'ON' : 'OFF'}  |  Palette: ${PALETTE_NAMES[currentPalette]}  |  ${w} × ${h}`;
  if (currentPalette === 'original') buildPaletteGrid();
}

function drawDialogOverlay(ctx, w, h) {
  // Box size 10–100 scales both width and height smoothly
  const sizeVal = Math.max(10, Math.min(100, dialogBoxSize));
  const scale = (sizeVal - 10) / 90; // 0 at 10, 1 at 100
  const boxW = Math.max(120, Math.round(w * (0.30 + 0.65 * scale)));
  const boxH = Math.max(56, Math.round(h * (0.08 + 0.28 * scale)));
  const fontSz = Math.max(24, Math.min(44, Math.floor(Math.min(boxW, boxH) / 5)));
  const pad = Math.max(8, Math.round(Math.min(boxW, boxH) / 10));
  const boxX = (w - boxW) / 2;
  const posPct = Math.max(0, Math.min(100, dialogPosition)) / 100;
  const boxY = Math.round((h - boxH - pad) * (1 - posPct)) + pad;

  ctx.save();
  ctx.font = `${fontSz}px "MS Sans Serif", "Microsoft Sans Serif", "Segoe UI", Tahoma, sans-serif`;

  const displayName = (dialogName || '').replace(/[:\s]+$/, '').trim();
  const rawText = (dialogText || '').replace(/^\s*>\s*/, '').trim();
  const textWithPrompt = rawText ? '> ' + rawText : '';
  const lineH = fontSz + 6;
  const nameGap = (displayName && textWithPrompt) ? Math.round(lineH * 0.3) : 0;

  // Count lines for vertical centering
  let numLines = 0;
  if (displayName) numLines++;
  if (textWithPrompt) numLines++;
  const totalH = numLines * lineH + nameGap;
  const startY = boxY + (boxH - totalH) / 2 + fontSz;
  const textX = boxX + pad;

  if (dialogStyle === 'jrpg') {
    ctx.fillStyle = '#000080';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    ctx.strokeRect(boxX + 2, boxY + 2, boxW - 4, boxH - 4);
    let curY = startY;
    if (displayName) {
      ctx.fillStyle = '#ffff00';
      ctx.fillText(displayName, textX, curY);
      curY += lineH + nameGap;
    }
    ctx.fillStyle = '#ffffff';
    if (textWithPrompt) ctx.fillText(textWithPrompt, textX, curY);

  } else if (dialogStyle === 'classic') {
    ctx.fillStyle = '#000000';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    let curY = startY;
    if (displayName) {
      ctx.fillStyle = '#ffff00';
      ctx.fillText(displayName, textX, curY);
      curY += lineH + nameGap;
    }
    ctx.fillStyle = '#ffffff';
    if (textWithPrompt) ctx.fillText(textWithPrompt, textX, curY);

  } else if (dialogStyle === 'ghost') {
    let curY = startY;
    if (displayName) {
      drawOutlinedText(ctx, displayName, textX, curY, '#ffff00', '#000000', 2);
      curY += lineH + nameGap;
    }
    if (textWithPrompt) drawOutlinedText(ctx, textWithPrompt, textX, curY, '#ffffff', '#000000', 2);

  } else {
    // Modern
    ctx.fillStyle = 'rgba(42,42,42,0.85)';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(boxX + 1, boxY + 1, boxW - 2, boxH - 2);
    let curY = startY;
    if (displayName) {
      ctx.fillStyle = '#aaccff';
      ctx.fillText(displayName, textX, curY);
      curY += lineH + nameGap;
    }
    ctx.fillStyle = '#ffffff';
    if (textWithPrompt) ctx.fillText(textWithPrompt, textX, curY);
  }

  ctx.restore();
}

function drawOutlinedText(ctx, str, x, y, fillColor, outlineColor, thickness) {
  ctx.fillStyle = outlineColor;
  for (let dx = -thickness; dx <= thickness; dx++) {
    for (let dy = -thickness; dy <= thickness; dy++) {
      if (dx !== 0 || dy !== 0) ctx.fillText(str, x + dx, y + dy);
    }
  }
  ctx.fillStyle = fillColor;
  ctx.fillText(str, x, y);
}

function drawCanvasBorder(ctx, w, h) {
  ctx.save();
  if (borderStyle === 'blackwhite') {
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 14;
    ctx.strokeRect(0, 0, w, h);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.strokeRect(7, 7, w - 14, h - 14);
  } else if (borderStyle === 'navy') {
    ctx.strokeStyle = '#000080';
    ctx.lineWidth = 14;
    ctx.strokeRect(0, 0, w, h);
    ctx.strokeStyle = '#4169e1';
    ctx.lineWidth = 4;
    ctx.strokeRect(7, 7, w - 14, h - 14);
  }
  ctx.restore();
}

function downsampleBlocks(src, w, h, blockSize) {
  const out = new Uint8ClampedArray(src.length);
  for (let by = 0; by < h; by += blockSize) {
    for (let bx = 0; bx < w; bx += blockSize) {
      const bw = Math.min(blockSize, w - bx);
      const bh = Math.min(blockSize, h - by);
      const count = bw * bh;
      let rSum = 0, gSum = 0, bSum = 0;
      for (let y = by; y < by + bh; y++) {
        for (let x = bx; x < bx + bw; x++) {
          const i = (y * w + x) * 4;
          rSum += src[i];
          gSum += src[i + 1];
          bSum += src[i + 2];
        }
      }
      const avgR = rSum / count;
      const avgG = gSum / count;
      const avgB = bSum / count;
      for (let y = by; y < by + bh; y++) {
        for (let x = bx; x < bx + bw; x++) {
          const i = (y * w + x) * 4;
          out[i] = avgR;
          out[i + 1] = avgG;
          out[i + 2] = avgB;
          out[i + 3] = 255;
        }
      }
    }
  }
  return out;
}

function applyPaletteBayer(src, w, h, blockSize, palette, dither) {
  const out = new Uint8ClampedArray(w * h * 4);
  for (let by = 0; by < h; by += blockSize) {
    for (let bx = 0; bx < w; bx += blockSize) {
      const bw = Math.min(blockSize, w - bx);
      const bh = Math.min(blockSize, h - by);
      const count = bw * bh;
      let rSum = 0, gSum = 0, bSum = 0;
      for (let y = by; y < by + bh; y++) {
        for (let x = bx; x < bx + bw; x++) {
          const i = (y * w + x) * 4;
          rSum += src[i];
          gSum += src[i + 1];
          bSum += src[i + 2];
        }
      }
      let avgR = rSum / count;
      let avgG = gSum / count;
      let avgB = bSum / count;
      if (dither) {
        const t = (BAYER_8X8[by % 8][bx % 8] / 64) - 0.5;
        const bias = t * 48;
        avgR = Math.max(0, Math.min(255, avgR + bias));
        avgG = Math.max(0, Math.min(255, avgG + bias));
        avgB = Math.max(0, Math.min(255, avgB + bias));
      }
      const [nr, ng, nb] = findNearestRedmean(avgR, avgG, avgB, palette);
      for (let y = by; y < by + bh; y++) {
        for (let x = bx; x < bx + bw; x++) {
          const i = (y * w + x) * 4;
          out[i] = nr;
          out[i + 1] = ng;
          out[i + 2] = nb;
          out[i + 3] = 255;
        }
      }
    }
  }
  return out;
}

function findNearestRedmean(r, g, b, palette) {
  let best = palette[0];
  let bestDist = Infinity;
  for (const [pr, pg, pb] of palette) {
    const dr = r - pr;
    const dg = g - pg;
    const db = b - pb;
    const rBar = (r + pr) / 2;
    const termR = (2 + rBar / 256) * dr * dr;
    const termG = 4 * dg * dg;
    const termB = (2 + (255 - rBar) / 256) * db * db;
    const dist = Math.sqrt(termR + termG + termB);
    if (dist < bestDist) {
      bestDist = dist;
      best = [pr, pg, pb];
    }
  }
  return best;
}

function applyGhost(src, w, h, offsetX, offsetY, alpha) {
  const out = new Uint8ClampedArray(w * h * 4);
  out.set(src);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const sx = x - offsetX;
      const sy = y - offsetY;
      if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
        const dst = (y * w + x) * 4;
        const sIdx = (sy * w + sx) * 4;
        out[dst]   = Math.round(out[dst]   * (1 - alpha) + src[sIdx]   * alpha);
        out[dst+1] = Math.round(out[dst+1] * (1 - alpha) + src[sIdx+1] * alpha);
        out[dst+2] = Math.round(out[dst+2] * (1 - alpha) + src[sIdx+2] * alpha);
      }
    }
  }
  return out;
}

function applyOutline(src, w, h, blockSize, palette) {
  const out = new Uint8ClampedArray(src);
  let [orR, orG, orB] = palette[0] || [0, 0, 0];
  if (orR + orG + orB > 384) {
    orR = Math.max(0, orR - 80);
    orG = Math.max(0, orG - 80);
    orB = Math.max(0, orB - 80);
  }
  const lineW = blockSize >= 16 ? 2 : 1;
  const same = (i, j) =>
    src[i] === src[j] && src[i+1] === src[j+1] && src[i+2] === src[j+2];
  for (let by = 0; by < h; by += blockSize) {
    for (let bx = 0; bx < w; bx += blockSize) {
      const cur = (by * w + bx) * 4;
      const nRight = bx + blockSize < w ? ((by * w + bx + blockSize) * 4) : cur;
      const nBottom = by + blockSize < h ? (((by + blockSize) * w + bx) * 4) : cur;
      if (!same(cur, nRight)) {
        for (let dy = 0; dy < Math.min(blockSize, h - by); dy++) {
          for (let d = 0; d < lineW && bx + blockSize + d < w; d++) {
            const i = (by + dy) * w * 4 + (bx + blockSize + d) * 4;
            out[i] = orR; out[i+1] = orG; out[i+2] = orB;
          }
        }
      }
      if (!same(cur, nBottom)) {
        for (let dx = 0; dx < Math.min(blockSize, w - bx); dx++) {
          for (let d = 0; d < lineW && by + blockSize + d < h; d++) {
            const i = ((by + blockSize + d) * w + bx + dx) * 4;
            out[i] = orR; out[i+1] = orG; out[i+2] = orB;
          }
        }
      }
    }
  }
  return out;
}
</script>
</body>
</html>
